#include "communication.h"
#include "usart.h" // 需要用到 huart3
#include "encoder.h"
#include "speed_solver.h"
#include "OLED.h"
#include "main.h"
#include "string.h"

// --- 新通信协议宏定义 ---
static const uint8_t FRAME_HEADER_1 = 0xAA;
static const uint8_t FRAME_HEADER_2 = 0x55;
#define RX_BUFFER_SIZE 16// 新协议总长度为16字节

// --- 为新协议定义一个结构体，方便管理解析后的数据 ---
// __attribute__((packed)) 是为了让编译器取消字节对齐，确保结构体大小就是成员大小之和
/*
typedef __packed struct {
    uint16_t data_len;
    uint16_t cmd_id;
    float    turn_rad;
    float    distance;
} CommandPacket_t;
*/

// --- 全局变量定义 ---
// 定义一个结构体变量来存放最新、最有效的指令数据
volatile CommandPacket_t g_latest_command;
//volatile int cmd_id;

// --- Internal Static Variables ---
// Use the static keyword to restrict the scope of these variables to this file, 
// other files cannot access them.
 uint8_t uart3_rx_buffer[RX_BUFFER_SIZE];
static uint8_t uart3_rx_index = 0;
static uint8_t uart3_rx_byte;
uint8_t num[3000];
uint8_t buffer1[2600];
extern volatile int tip;
int i=0;
volatile int t=0;
// --- Global Variable Definitions ---
// Define global variables that need to be accessed across files.
volatile uint8_t g_new_command_flag = 0;


/**
 * @brief Initializes the communication module and starts the reception 
 * of data in the interface.
 */
void Communication_Init(void)
{
     // Start the USART3 (UART) reception mode, receiving 1 byte at a time.
    //HAL_UART_Receive_IT(&huart3, &uart3_rx_byte, 1);
	HAL_UART_Receive_DMA(&huart3, uart3_rx_buffer, 16);
}

// --- CRC16-CCITT 校验函数 ---
uint16_t crc16_ccitt(const uint8_t *p_data, uint16_t length)
{
    uint16_t crc = 0xFFFF;
    while (length--) {
        crc ^= (uint16_t)(*p_data++) << 8;
        for (uint8_t i = 0; i < 8; i++) {
            if (crc & 0x8000) {
                crc = (crc << 1) ^ 0x1021;
            } else {
                crc = crc << 1;
            }
        }
    }
    return crc;
}

// --- 解析接收到的完整数据帧 ---
static void parse_frame(void)
{  
    // 计算CRC (范围: 从第2字节到第13字节，共12字节)
  //  uint16_t calculated_crc = crc16_ccitt(&uart3_rx_buffer[2], 12);

    // 提取接收到的CRC (小端模式)
  //  uint16_t received_crc = (uint16_t)(uart3_rx_buffer[15] << 8) | uart3_rx_buffer[14];

    //if (calculated_crc == received_crc)
      //OLED_ShowString8X16(0,2,"it is");
        CommandPacket_t temp_cmd;
        memcpy(&temp_cmd, &uart3_rx_buffer[2], sizeof(CommandPacket_t));
     //   OLED_ShowString8X16(0,2,"it itff");
        if (temp_cmd.data_len == 10)
        {  
            g_latest_command = temp_cmd;
            g_new_command_flag = 1; 
        }
   }


/**
 * @brief Completes the UART reception callback function, this is the HAL 
 * library's weak function, we will implement it here.
 * @param huart: UART handle
 */
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
   // Determine if this interrupt is generated by USART3
/*    if(huart->Instance == USART3)
    {   
				switch (uart3_rx_index)
        {   
            case 0: // 等待第一个帧头
							// OLED_ShowString8X16(0,2,"it itff");
                if (uart3_rx_byte == FRAME_HEADER_1) {
                    uart3_rx_buffer[uart3_rx_index++] = uart3_rx_byte;
								//	  t++;
									//	OLED_ShowString8X16(0,2,"it is");
                }
                break;
            
            case 1: // 等待第二个帧头
                if (uart3_rx_byte == FRAME_HEADER_2) {
                    uart3_rx_buffer[uart3_rx_index++] = uart3_rx_byte;
									//OLED_ShowString8X16(0,2,"it is");
								//	  t++;
                } else {
                    uart3_rx_index = 0; // 序列错误，重置
                }
                break;

            default: // 接收剩余的数据
                uart3_rx_buffer[uart3_rx_index++] = uart3_rx_byte;
						//  t++;
                if (uart3_rx_index >= RX_BUFFER_SIZE)
                {   
                    parse_frame(); // 处理数据
                    uart3_rx_index = 0; // 重置
										//OLED_ShowString8X16(0,2,"it is");
									  tip=1;
                }
                break;
        }
        // 重新使能中断
				
        HAL_UART_Receive_IT(&huart3, &uart3_rx_byte, 1);
				
    }*/
		 if(huart->Instance == USART3){
		 tip=1;
			// cmd_id++;
		 }
		 // UART4 Interrupt
	else	 if (huart->Instance == UART4)
		{if(i>7){
		//OLED_ShowString8X16(0,0,"ROBOT can do");
		return;}
    extern uint8_t uart4_rx_byte;
   // extern void AX_LASER_RxCpltHandler(uint8_t); // Prevent duplicate calls
   num[i++]=uart4_rx_byte;
  	//	OLED_ShowString8X16(0,0,"ROBOT can do");
			if(i==7){
	       i++;
				HAL_UART_Receive_DMA(&huart4, buffer1, 2600);
				return;
			}
    HAL_UART_Receive_IT(&huart4, &uart4_rx_byte, 1);  
     }
}

// Brief: Timer TIM6 callback function
/**
 * @brief  Callback function triggered by the TIM6 timer overflow
 * @note   This function is called automatically by HAL when the timer updates (overflow)
 * @param  htim: Pointer to the timer handle
 * @retval None
 */
//void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
//{
  // Determine if the interrupt is generated by the TIM6 timer
 // if (htim->Instance == TIM6)
  //{
   
 //  Speed_Solver_Update();
//  }
		
//}

